# b78554b3956925b31d74b94f0427ba785c2fd31b4e82c7022ab573d4785d2545 Elan 1.4.0 guest default_profile valid

main
  variable reply set to ""
  repeat
    set reply to inputString('RETURN for time now or\nUnix time (positive integer) or\nQ to quit')
    if reply is "" then
      call printDate(clock() div 1000)
    else
      variable t, d set to parseAsInt(reply)
      if t and (d >= 0) then
        call printDate(d)
      end if
    end if
  end repeat when reply.upperCase() is "Q"
end main

procedure printDate(unixSecs as Int)
  let hour, minute, second, days, year, weekday be dateTime(unixSecs)
  let h be pad("L", z2, hour.asString())
  let m be pad("L", z2, minute.asString())
  let s be pad("L", z2, second.asString())
  let startDaysL be startDaysList(year, startDays)
  let month, day be monthDay(startDaysL, (days mod startDays[12]))
  print weekdayNames[weekday] + cs + pad("L", z2, day.asString()) + s1 + monthNames[month - 1] + s1 + "{year}" + s1 + h + co + m + co + s + " UTC\n"
end procedure

function dateTime(unixSecs as Int) returns (Int, Int, Int, Int, Int, Int)
  # get separate values from Unix time
  let hour be ((unixSecs div 60) div 60) mod 24
  let minute be (unixSecs div 60) mod 60
  let second be (unixSecs mod 60)
  # days and years from Unix epoch
  let unixDay be unixSecs div daySecs
  let years be ((unixDay + 1)/365.24).floor()
  # this year and weekday
  let year be unixYear + years
  let weekday be (unixDay + unixWeekday) mod 7
  # day number (1-365 or 1-366) in this year
  let day be dayInYear(year, unixDay)
  return tuple(hour, minute, second, day, year, weekday)
end function

function dayInYear(year as Int, unixDays as Int) returns Int
  # unixDays start at 0, months' day numbers start at 1
  variable dayNumber set to unixDays + 1
  if year > unixYear then
    # discount previous nominal years
    set dayNumber to dayNumber - 365*(year - unixYear)
    # discount previous leap days
    for y from unixYear to (year - 1) step 1
      if leap(y) then
        set dayNumber to dayNumber - 1
      end if
    end for
  end if
  return dayNumber
end function

function leap(year as Int) returns Boolean
  variable leapYear set to false
  if (year mod 4) is 0 then
    set leapYear to true
    if ((year mod 100) is 0) and (((year div 100) mod 4) isnt 0) then
      set leapYear to false
    end if
  end if
  return leapYear
end function

function monthDay(startDays as List<of Int>, dayNumber as Int) returns (Int, Int)
  # get month (1-12) & day (1-31) from dayNumber (1-365 or 1-366)
  variable month set to 1
  variable day set to 0
  variable monthFound set to false
  repeat
    if (dayNumber < startDays[month]) then
      set monthFound to true
      set day to dayNumber - startDays[month - 1] + 1
    else
      set month to month + 1
    end if
  end repeat when monthFound
  return tuple(month, day)
end function

function startDaysList(year as Int, startDays as ListImmutable<of Int>) returns List<of Int>
  # alter month start days if leap year
  variable startDaysL set to startDays.asList()
  if leap(year) then
    for m from 2 to 12 step 1
      set startDaysL to startDaysL.withPut(m, startDaysL[m] + 1)
    end for
  end if
  return startDaysL
end function

# Unix epoch is 1970.01.01 00:00:00 Thursday
constant unixYear set to 1970

constant unixWeekday set to 4

# day and month names, and day numbers
constant daySecs set to 86400

constant weekdayNames set to {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}

constant monthNames set to {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

constant startDays set to {1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}

# output edit strings
constant s1 set to " "

constant z2 set to "00"

constant cs set to ", "

constant co set to ":"

function pad(d as String, p as String, s as String) returns String
  # d: L or R for pad left or right
  # p: output string pattern of pad characters and of length
  # s: input string
  variable sR set to s
  if p.length() > s.length() then
    if d.upperCase() is "L" then
      set sR to (p + s)[(p + s).length() - p.length()..]
    else if d.upperCase() is "R" then
      set sR to (s + p)[..p.length()]
    end if
  end if
  return sR
end function
